<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nice!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        .center-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Times New Roman', Times, serif;
            font-size: clamp(1.5rem, 5vw, 3rem);
            color: black;
            text-shadow: -2px -2px 0 white, 2px -2px 0 white, -2px 2px 0 white, 2px 2px 0 white;
            z-index: 1000;
            pointer-events: none;
            font-weight: bold;
            text-align: center;
            padding: 0 20px;
            max-width: 90vw;
        }
        .cube-container {
            position: absolute;
            width: 100px;
            height: 100px;
            perspective: 1000px;
        }
        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            animation: rotateCube 10s infinite linear;
        }
        @keyframes rotateCube {
            from { transform: rotateX(0deg) rotateY(0deg); }
            to { transform: rotateX(360deg) rotateY(360deg); }
        }
        .cube-face {
            position: absolute;
            width: 100px;
            height: 100px;
            background-size: cover;
            background-position: center;
            border: 2px solid white;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        .front  { transform: rotateY(0deg) translateZ(50px); }
        .back   { transform: rotateY(180deg) translateZ(50px); }
        .right  { transform: rotateY(90deg) translateZ(50px); }
        .left   { transform: rotateY(-90deg) translateZ(50px); }
        .top    { transform: rotateX(90deg) translateZ(50px); }
        .bottom { transform: rotateX(-90deg) translateZ(50px); }

        /* Desktop styles */
        @media (min-width: 769px) {
            .cube-container {
                width: 150px;
                height: 150px;
            }
            .cube-face {
                width: 150px;
                height: 150px;
            }
            .front  { transform: rotateY(0deg) translateZ(75px); }
            .back   { transform: rotateY(180deg) translateZ(75px); }
            .right  { transform: rotateY(90deg) translateZ(75px); }
            .left   { transform: rotateY(-90deg) translateZ(75px); }
            .top    { transform: rotateX(90deg) translateZ(75px); }
            .bottom { transform: rotateX(-90deg) translateZ(75px); }
        }
    </style>
</head>
<body>
    <div class="center-text">"a big part of my life"</div>
    <script>
        // Detect if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 769;
        
        // Adjust number of cubes based on device
        const totalCubes = 29;
        const numCubes = isMobile ? 10 : 29; // Reduce from 29 to 10 on mobile
        const cubeSize = isMobile ? 100 : 150;
        
        // Generate random cube indices for mobile
        let cubeIndices = [];
        if (isMobile) {
            // Create array of all possible indices [0-28]
            const allIndices = Array.from({length: totalCubes}, (_, i) => i);
            // Shuffle and take first 10
            for (let i = allIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];
            }
            cubeIndices = allIndices.slice(0, numCubes);
        } else {
            // Use all cubes on desktop
            cubeIndices = Array.from({length: totalCubes}, (_, i) => i);
        }
        
        // Array to store cube objects
        const cubes = [];
        let animationFrameId;
        
        // Create cubes
        for (let i = 0; i < cubeIndices.length; i++) {
            const cubeIndex = cubeIndices[i];
            const container = document.createElement('div');
            container.className = 'cube-container';
            
            const cube = document.createElement('div');
            cube.className = 'cube';
            
            // Create 6 faces for each cube
            const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
            faces.forEach((face, index) => {
                const faceDiv = document.createElement('div');
                faceDiv.className = `cube-face ${face}`;
                
                // Calculate image number based on the actual cube index
                const imageNum = cubeIndex * 6 + index + 1;
                
                // Try loading both .jpg and .jpeg extensions
                const img = new Image();
                img.onload = function() {
                    faceDiv.style.backgroundImage = `url('image${imageNum}.jpg')`;
                };
                img.onerror = function() {
                    // Try .jpeg if .jpg fails
                    const imgJpeg = new Image();
                    imgJpeg.onload = function() {
                        faceDiv.style.backgroundImage = `url('image${imageNum}.jpeg')`;
                    };
                    imgJpeg.onerror = function() {
                        // If both fail, try without extension (let browser decide)
                        faceDiv.style.backgroundImage = `url('image${imageNum}')`;
                    };
                    imgJpeg.src = `image${imageNum}.jpeg`;
                };
                img.src = `image${imageNum}.jpg`;
                
                cube.appendChild(faceDiv);
            });
            
            container.appendChild(cube);
            document.body.appendChild(container);
            
            // Initialize position and velocity
            cubes.push({
                element: container,
                x: Math.random() * (window.innerWidth - cubeSize),
                y: Math.random() * (window.innerHeight - cubeSize),
                vx: (Math.random() - 0.5) * (isMobile ? 2 : 4), // Slower on mobile
                vy: (Math.random() - 0.5) * (isMobile ? 2 : 4)
            });
        }
        
        // Track last update time for throttling
        let lastUpdate = Date.now();
        const updateInterval = isMobile ? 32 : 16; // ~30fps on mobile, ~60fps on desktop
        
        // Animation loop
        function animate() {
            const now = Date.now();
            const delta = now - lastUpdate;
            
            // Throttle updates on mobile
            if (delta >= updateInterval) {
                cubes.forEach(cube => {
                    // Update position
                    cube.x += cube.vx;
                    cube.y += cube.vy;
                    
                    // Bounce off walls
                    if (cube.x <= 0 || cube.x >= window.innerWidth - cubeSize) {
                        cube.vx *= -1;
                        cube.x = Math.max(0, Math.min(cube.x, window.innerWidth - cubeSize));
                    }
                    if (cube.y <= 0 || cube.y >= window.innerHeight - cubeSize) {
                        cube.vy *= -1;
                        cube.y = Math.max(0, Math.min(cube.y, window.innerHeight - cubeSize));
                    }
                    
                    // Apply position with transform for better performance
                    cube.element.style.transform = `translate(${cube.x}px, ${cube.y}px)`;
                });
                
                lastUpdate = now;
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Start animation after a brief delay to let page settle
        setTimeout(() => {
            animate();
        }, 100);
        
        // Handle orientation changes on mobile
        window.addEventListener('resize', () => {
            // Cancel current animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Reposition cubes within new boundaries
            cubes.forEach(cube => {
                cube.x = Math.min(cube.x, window.innerWidth - cubeSize);
                cube.y = Math.min(cube.y, window.innerHeight - cubeSize);
                cube.element.style.transform = `translate(${cube.x}px, ${cube.y}px)`;
            });
            
            // Restart animation
            setTimeout(() => {
                animate();
            }, 100);
        });
    </script>
</body>
</html>
